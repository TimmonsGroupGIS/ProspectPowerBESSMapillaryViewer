<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prospect Power BESS, VA Dedicated Mapillary Viewer Page</title>
    
    <!-- MapillaryJS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
    <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>
    
    <!-- MapLibre GL -->
    <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            height: 100%;
            font-family: Arial, sans-serif;
        }
        #container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }
        #viewer {
            width: 50%;
            height: 100%;
        }
        #map {
            width: 50%;
            height: 100%;
        }
        #status {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 16px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
            font-size: 13px;
            max-width: 300px;
        }
        #progress-container {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 280px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 16px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
            display: none;
        }
        #progress-container.visible {
            display: block;
        }
        #progress-label {
            font-size: 13px;
            margin-bottom: 8px;
        }
        #progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 8px;
        }
        #progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4285F4, #34A853);
            width: 0%;
            transition: width 0.3s ease;
        }
        #progress-text {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }
        #error-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            padding: 24px 32px;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
            z-index: 2000;
            display: none;
            text-align: center;
            max-width: 400px;
        }
        #error-container.visible {
            display: block;
        }
        #error-container h3 {
            color: #d32f2f;
            margin-bottom: 12px;
            font-size: 18px;
        }
        #error-container p {
            color: #666;
            margin-bottom: 20px;
            line-height: 1.5;
        }
        #error-container button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 20px;
            font-weight: 500;
            transition: background 0.2s;
        }
        #reload-btn {
            background: #4285F4;
            color: white;
        }
        #reload-btn:hover {
            background: #3367D6;
        }
        #mapillary-btn {
            background: #34A853;
            color: white;
        }
        #mapillary-btn:hover {
            background: #2D9348;
        }
        #mapillary-direct-btn {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: #E0E0E0;
            color: #000;
            font-weight: bold;
            padding: 10px 16px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 13px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
        }
        #mapillary-direct-btn:hover {
            background: #D0D0D0;
        }
        #mapillary-direct-btn img {
            width: 35px;
            height: 35px;
        }
        #zoom-warning {
            position: absolute;
            bottom: 60px;
            left: 10px;
            background: rgba(255, 193, 7, 0.95);
            color: #000;
            padding: 10px 16px;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            z-index: 1000;
            font-size: 13px;
            display: none;
        }
        #zoom-warning.visible {
            display: block;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="viewer">
            <div id="status" style="display: none;">Please wait. Loading images from Mapillary API...</div>
            <div id="progress-container">
                <div id="progress-label">Please wait. Loading images from Mapillary API...</div>
                <div id="progress-bar">
                    <div id="progress-fill"></div>
                </div>
                <div id="progress-text">Request 0 of ?</div>
            </div>
            <button id="mapillary-direct-btn">
                <img src="https://play-lh.googleusercontent.com/z3qzEc13E2sDWky9LgqADojcdy8hrX_szuAAeX21k_dFe7GNXLIYXJtOu5RcE3_5Jz8" alt="Mapillary">
                Open Timmons Prospect Power BESS Mapillary Data Directly
            </button>
            <div id="zoom-warning">
                ⚠️ Zoom in closer to load imagery
            </div>
        </div>
        <div id="map"></div>
    </div>
    
    <div id="error-container">
        <h3>⚠️ Loading Error</h3>
        <p id="error-message">Mapillary API issue occurred during imagery fetch. Would you like to try reloading?</p>
        <p id="error-message"><i>You can also open filtered Mapillary data by using th button in the bottom left of the screen.<i></i></p>
        <div>
            <button id="reload-btn">Try Reload</button>
        </div>
    </div>

    <script>
        const TOKEN = 'MLY|24840280672250420|6fc0e204403850a11ccc043866f1b01d';
        const START_ID = '1878629616050462';
        const USERNAME = 'vukmercd23';
        
        // INITIAL CENTER POINT - Start with a smaller area
        const INITIAL_CENTER = {
            lng: -78.6988,  // Center longitude
            lat: 38.6111    // Center latitude
        };
        
        // CONFIGURATION
        const MIN_ZOOM_FOR_FETCH = 14;  // Don't fetch images if zoomed out beyond this
        const MAX_BBOX_AREA = 0.009;    // Maximum area in square degrees (slightly under API limit of 0.010)
        
        let imageData = [];
        let isUpdatingFromViewer = false;
        let isUpdatingFromMap = false;
        let isFetching = false;
        let lastFetchedBounds = null;
        let fetchTimeout = null;
        
        const status = (text) => {
            document.getElementById('status').textContent = text;
        };
        
        const showProgress = (show) => {
            const container = document.getElementById('progress-container');
            if (show) {
                container.classList.add('visible');
            } else {
                container.classList.remove('visible');
            }
        };
        
        const updateProgress = (current, total, filtered) => {
            const percent = total > 0 ? Math.round((current / total) * 100) : 0;
            document.getElementById('progress-fill').style.width = percent + '%';
            document.getElementById('progress-text').textContent = 
                `Request ${current} of ~${total} | ${filtered} images loaded`;
        };
        
        const showError = (message) => {
            const errorContainer = document.getElementById('error-container');
            document.getElementById('error-message').textContent = message || 
                'Mapillary API issue occurred. Would you like to try reloading?';
            errorContainer.classList.add('visible');
            showProgress(false);
        };
        
        const hideError = () => {
            document.getElementById('error-container').classList.remove('visible');
        };
        
        const showZoomWarning = (show) => {
            const warning = document.getElementById('zoom-warning');
            if (show) {
                warning.classList.add('visible');
            } else {
                warning.classList.remove('visible');
            }
        };
        
        // Error dialog button handlers
        document.getElementById('reload-btn').addEventListener('click', () => {
            hideError();
            location.reload();
        });
        
        // Mapillary direct button (always visible)
        document.getElementById('mapillary-direct-btn').addEventListener('click', () => {
            window.open('https://www.mapillary.com/app/user/vukmercd23?lat=38.61371815016656&lng=-78.69812659093867&z=18.75&dateFrom=2025-09-25&username%5B%5D=vukmercd23&dateTo=2025-09-27&pKey=1878629616050462', '_blank');
        });

        // Initialize Mapillary Viewer
        const viewer = new mapillary.Viewer({
            container: 'viewer',
            accessToken: TOKEN,
            imageId: START_ID,
            component: {
                cover: false,
                sequence: true,
                direction: true,
                zoom: true
            }
        });

        // Initialize MapLibre map
        const map = new maplibregl.Map({
            container: 'map',
            style: {
                version: 8,
                sources: {
                    osm: {
                        type: 'raster',
                        tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
                        tileSize: 256,
                        attribution: '© OpenStreetMap contributors'
                    }
                },
                layers: [
                    { id: 'osm', type: 'raster', source: 'osm' }
                ]
            },
            center: [INITIAL_CENTER.lng, INITIAL_CENTER.lat],
            zoom: 15
        });

        // Calculate bounding box area in square degrees
        function calculateBBoxArea(bounds) {
            const width = bounds.getEast() - bounds.getWest();
            const height = bounds.getNorth() - bounds.getSouth();
            return width * height;
        }

        // Check if we need to refetch based on map movement
        function shouldRefetch(currentBounds) {
            if (!lastFetchedBounds) return true;
            
            // Check if current view extends beyond last fetched bounds
            const current = {
                north: currentBounds.getNorth(),
                south: currentBounds.getSouth(),
                east: currentBounds.getEast(),
                west: currentBounds.getWest()
            };
            
            const last = {
                north: lastFetchedBounds.getNorth(),
                south: lastFetchedBounds.getSouth(),
                east: lastFetchedBounds.getEast(),
                west: lastFetchedBounds.getWest()
            };
            
            // Refetch if we've moved 50% outside the previous bounds
            const marginLat = (last.north - last.south) * 0.5;
            const marginLng = (last.east - last.west) * 0.5;
            
            return (
                current.north > last.north + marginLat ||
                current.south < last.south - marginLat ||
                current.east > last.east + marginLng ||
                current.west < last.west - marginLng
            );
        }

        // Fetch images for current viewport
        async function fetchImagesForViewport() {
            const zoom = map.getZoom();
            
            // Check if zoom level is sufficient
            if (zoom < MIN_ZOOM_FOR_FETCH) {
                showZoomWarning(true);
                status('Zoom in to load imagery');
                return;
            }
            
            showZoomWarning(false);
            
            const bounds = map.getBounds();
            const area = calculateBBoxArea(bounds);
            
            // Check if area is too large
            if (area > MAX_BBOX_AREA) {
                showZoomWarning(true);
                status('Zoom in closer to load imagery');
                console.log(`Viewport area too large: ${area.toFixed(4)} > ${MAX_BBOX_AREA}`);
                return;
            }
            
            // Check if we need to refetch
            if (!shouldRefetch(bounds)) {
                console.log('Already have images for this area');
                return;
            }
            
            if (isFetching) {
                console.log('Already fetching, skipping...');
                return;
            }
            
            try {
                isFetching = true;
                status('Loading images...');
                showProgress(true);
                
                const bbox = {
                    min_lng: bounds.getWest(),
                    min_lat: bounds.getSouth(),
                    max_lng: bounds.getEast(),
                    max_lat: bounds.getNorth()
                };
                
                console.log(`Fetching images for bbox:`, bbox);
                console.log(`Bbox area: ${area.toFixed(4)} square degrees`);
                
                let allImages = [];
                let after = null;
                let requestCount = 0;
                let totalFetched = 0;
                const estimatedTotal = 10;
                
                // Fetch all pages
                while (true) {
                    const url = new URL('https://graph.mapillary.com/images');
                    url.searchParams.set('access_token', TOKEN);
                    url.searchParams.set('fields', 'id,geometry,compass_angle,sequence,captured_at,creator');
                    
                    const bboxString = `${bbox.min_lng},${bbox.min_lat},${bbox.max_lng},${bbox.max_lat}`;
                    url.searchParams.set('bbox', bboxString);
                    
                    // Filter by username
                    url.searchParams.set('creator_username', USERNAME);
                    
                    url.searchParams.set('limit', 2000);
                    if (after) {
                        url.searchParams.set('after', after);
                    }
                    
                    const response = await fetch(url);
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error(`HTTP ${response.status}: ${errorText}`);
                        
                        // Check if it's a bounding box error
                        if (response.status === 500 && errorText.includes('Bounding box area is too large')) {
                            showZoomWarning(true);
                            status('Zoom in closer to load imagery');
                            showProgress(false);
                            isFetching = false;
                            return;
                        }
                        
                        showError(`API Error (${response.status}): Failed to load imagery data. Would you like to try reloading?`);
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const data = await response.json();
                    const images = data.data || [];
                    
                    requestCount++;
                    totalFetched += images.length;
                    console.log(`Request ${requestCount}: got ${images.length} images (total fetched: ${totalFetched})`);
                    
                    if (images.length === 0) break;
                    
                    allImages = allImages.concat(images);
                    updateProgress(requestCount, estimatedTotal, allImages.length);
                    status(`Loading: ${allImages.length} images...`);
                    
                    // Check if there's more data
                    if (data.paging && data.paging.cursors && data.paging.cursors.after) {
                        after = data.paging.cursors.after;
                    } else {
                        console.log('No more pages available');
                        break;
                    }
                    
                    // Safety limit
                    if (requestCount >= 30) {
                        console.log('Reached maximum request limit');
                        break;
                    }
                    
                    // Stop if we've collected enough images
                    if (allImages.length >= 60000) {
                        console.log('Reached maximum of 60,000 images');
                        allImages = allImages.slice(0, 60000);
                        break;
                    }
                }
                
                showProgress(false);
                console.log(`\n=== FINAL RESULTS ===`);
                console.log(`Total API requests: ${requestCount}`);
                console.log(`Total images fetched: ${totalFetched}`);
                console.log(`===================\n`);
                
                // Merge with existing images (avoid duplicates)
                const existingIds = new Set(imageData.map(img => img.id));
                const newImages = allImages.filter(img => !existingIds.has(img.id));
                
                imageData = [...imageData, ...newImages];
                
                console.log(`Added ${newImages.length} new images, total: ${imageData.length}`);
                
                if (imageData.length === 0) {
                    status(`No images found in this area`);
                } else {
                    status(`Loaded ${imageData.length} images`);
                }
                
                lastFetchedBounds = bounds;
                addImagesToMap();
                
            } catch (err) {
                status('Error loading images: ' + err.message);
                console.error('Error fetching images:', err);
                if (!err.message.includes('bounding box')) {
                    showError(`Error loading imagery: ${err.message}. Would you like to try reloading? You can also load Mapillary directly, using the button at the bottom left of the screen.`);
                }
            } finally {
                isFetching = false;
            }
        }

        // Debounced fetch on map move
        function onMapMove() {
            if (fetchTimeout) {
                clearTimeout(fetchTimeout);
            }
            
            fetchTimeout = setTimeout(() => {
                fetchImagesForViewport();
            }, 500); // Wait 500ms after user stops moving the map
        }

        // Add images to map as GeoJSON
        function addImagesToMap() {
            const features = [];
            const sequenceGroups = {};
            
            // Single pass through data to build both features and sequence groups
            for (const img of imageData) {
                if (!img.geometry || !img.geometry.coordinates) continue;
                
                const coords = img.geometry.coordinates;
                
                // Add point feature
                features.push({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: coords
                    },
                    properties: {
                        id: img.id,
                        compass_angle: img.compass_angle || 0,
                        sequence: img.sequence || null
                    }
                });
                
                // Group for sequences
                if (img.sequence) {
                    if (!sequenceGroups[img.sequence]) {
                        sequenceGroups[img.sequence] = [];
                    }
                    sequenceGroups[img.sequence].push({
                        coords: coords,
                        captured_at: img.captured_at
                    });
                }
            }

            // Create line features from sequences
            const lineFeatures = [];
            for (const [seqId, points] of Object.entries(sequenceGroups)) {
                if (points.length < 2) continue;
                
                if (points[0].captured_at) {
                    points.sort((a, b) => new Date(a.captured_at) - new Date(b.captured_at));
                }
                
                lineFeatures.push({
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: points.map(p => p.coords)
                    },
                    properties: {
                        sequence: seqId
                    }
                });
            }

            console.log(`Adding ${features.length} points and ${lineFeatures.length} lines to map`);

            // Update the sources
            if (map.getSource('images')) {
                map.getSource('images').setData({
                    type: 'FeatureCollection',
                    features: features
                });
            }
            
            if (map.getSource('sequences')) {
                map.getSource('sequences').setData({
                    type: 'FeatureCollection',
                    features: lineFeatures
                });
            }
        }

        // FOV indicator
        function makeArcPath(fovDeg) {
            const r = 45, cx = 50, cy = 50;
            const rad = Math.PI / 180 * fovDeg;
            const a0 = -Math.PI / 2 - rad / 2;
            const a1 = a0 + rad;
            const x0 = cx + r * Math.cos(a0);
            const y0 = cy + r * Math.sin(a0);
            const x1 = cx + r * Math.cos(a1);
            const y1 = cy + r * Math.sin(a1);
            return `M ${cx} ${cy} L ${x0} ${y0} A ${r} ${r} 0 0 1 ${x1} ${y1} Z`;
        }

        function makeCamera(bearingDeg, fovDeg) {
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', makeArcPath(fovDeg));
            path.setAttribute('fill', '#4285F4');
            path.setAttribute('fill-opacity', '0.5');
            path.setAttribute('stroke', 'white');
            path.setAttribute('stroke-width', '2');
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 100 100');
            svg.appendChild(path);
            svg.style.height = '100%';
            svg.style.width = '100%';
            svg.style.transform = `rotateZ(${bearingDeg}deg)`;
            
            const el = document.createElement('div');
            el.style.height = '80px';
            el.style.width = '80px';
            el.appendChild(svg);
            return el;
        }

        const cameraEl = makeCamera(0, 90);
        const cameraMarker = new maplibregl.Marker({
            element: cameraEl,
            rotationAlignment: 'map'
        });

        const posDot = document.createElement('div');
        posDot.style.cssText = 'width:14px;height:14px;border:3px solid #EA4335;border-radius:50%;background:#fff;';
        const positionMarker = new maplibregl.Marker({
            element: posDot,
            rotationAlignment: 'map'
        });

        // Sync viewer position to map
        async function syncPosition() {
            if (isUpdatingFromMap) return;
            
            try {
                isUpdatingFromViewer = true;
                const pos = await viewer.getPosition();
                const pov = await viewer.getPointOfView();
                
                // Update position markers
                positionMarker.setLngLat([pos.lng, pos.lat]).addTo(map);
                cameraMarker.setLngLat([pos.lng, pos.lat]).addTo(map);
                
                // Update FOV rotation
                const svg = cameraEl.querySelector('svg');
                if (svg) {
                    svg.style.transform = `rotateZ(${pov.bearing}deg)`;
                }
                
                // Update highlighted point
                if (map.getSource('currentImage')) {
                    map.getSource('currentImage').setData({
                        type: 'FeatureCollection',
                        features: [{
                            type: 'Feature',
                            geometry: {
                                type: 'Point',
                                coordinates: [pos.lng, pos.lat]
                            }
                        }]
                    });
                }
                
                // Only pan if we're not already updating from a map click
                if (!isUpdatingFromMap) {
                    map.panTo([pos.lng, pos.lat]);
                }
                
                setTimeout(() => { isUpdatingFromViewer = false; }, 200);
            } catch (err) {
                console.error('Error syncing position:', err);
                isUpdatingFromViewer = false;
            }
        }

        // Update FOV when it changes
        viewer.on('fov', async () => {
            try {
                const vc = viewer.getContainer();
                const vFov = Math.PI / 180 * (await viewer.getFieldOfView());
                const aspect = vc.offsetHeight ? vc.offsetWidth / vc.offsetHeight : 0;
                const hFovDeg = Math.atan(aspect * Math.tan(0.5 * vFov)) * 2 * 180 / Math.PI;
                const path = cameraEl.querySelector('path');
                if (path) {
                    path.setAttribute('d', makeArcPath(hFovDeg));
                }
            } catch (err) {
                console.error('Error updating FOV:', err);
            }
        });

        // Set up viewer event listeners
        viewer.on('load', syncPosition);
        viewer.on('image', syncPosition);
        viewer.on('position', syncPosition);
        viewer.on('pov', syncPosition);

        window.addEventListener('resize', () => {
            if (viewer.emit) viewer.emit('fov');
        });

        // Initialize when map loads
        map.on('load', () => {
            // Create empty sources first
            map.addSource('sequences', {
                type: 'geojson',
                data: { type: 'FeatureCollection', features: [] }
            });

            map.addLayer({
                id: 'sequence-lines',
                type: 'line',
                source: 'sequences',
                paint: {
                    'line-color': '#4285F4',
                    'line-width': 2,
                    'line-opacity': 0.6
                }
            });

            map.addSource('images', {
                type: 'geojson',
                data: { type: 'FeatureCollection', features: [] }
            });

            map.addLayer({
                id: 'image-points',
                type: 'circle',
                source: 'images',
                paint: {
                    'circle-color': '#4285F4',
                    'circle-radius': ['interpolate', ['linear'], ['zoom'], 12, 3, 18, 8],
                    'circle-stroke-width': 2,
                    'circle-stroke-color': '#1976D2',
                    'circle-opacity': 0.8
                }
            });

            map.addSource('currentImage', {
                type: 'geojson',
                data: { type: 'FeatureCollection', features: [] }
            });
            
            map.addLayer({
                id: 'current-image',
                type: 'circle',
                source: 'currentImage',
                paint: {
                    'circle-color': '#EA4335',
                    'circle-radius': ['interpolate', ['linear'], ['zoom'], 12, 5, 18, 12],
                    'circle-stroke-width': 3,
                    'circle-stroke-color': '#fff'
                }
            });

            // Click handler
            map.on('click', 'image-points', async (e) => {
                if (isUpdatingFromViewer) return;
                
                const feature = e.features[0];
                const imageId = feature.properties.id;
                const coords = feature.geometry.coordinates;
                
                if (imageId) {
                    isUpdatingFromMap = true;
                    
                    // Update highlighted point immediately
                    if (map.getSource('currentImage')) {
                        map.getSource('currentImage').setData({
                            type: 'FeatureCollection',
                            features: [{
                                type: 'Feature',
                                geometry: {
                                    type: 'Point',
                                    coordinates: coords
                                }
                            }]
                        });
                    }
                    
                    // Update position markers immediately
                    positionMarker.setLngLat(coords).addTo(map);
                    cameraMarker.setLngLat(coords).addTo(map);
                    
                    // Center map on selected point
                    map.panTo(coords);
                    
                    try {
                        await viewer.moveTo(String(imageId));
                        // Force a position sync after the image loads
                        setTimeout(syncPosition, 100);
                    } catch (err) {
                        console.error('Error moving to image:', err);
                    }
                    setTimeout(() => { isUpdatingFromMap = false; }, 300);
                }
            });

            map.on('mouseenter', 'image-points', () => {
                map.getCanvas().style.cursor = 'pointer';
            });

            map.on('mouseleave', 'image-points', () => {
                map.getCanvas().style.cursor = '';
            });

            // Set up map move handlers for dynamic fetching
            map.on('moveend', onMapMove);
            map.on('zoomend', onMapMove);

            // Initial fetch
            fetchImagesForViewport();
        });
    </script>
</body>
</html>
